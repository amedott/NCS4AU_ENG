--track0: 分割数, 0, 1000, 100, 1
--track1: 高さ, 0, 1000, 100, 0.01
--track2: 周期, 0, 1000, 40, 0.01
--track3: Z, -10000, 10000 0, 0.01

--dialog: 色/col, local color=0xffffff; サイズ, local pointerSize=8; 音声同期/chk, local audioReact=true;
local DEBUG_MODE = false


--== Pre Processing ==--
obj.setfont ("MS UI Gothic", 50, 0, 0xffffff)
obj.setoption ("drawtarget", "tempbuffer", obj.screen_w, obj.screen_h)
--====================--

--== Parsing Variables ==--
local resolution = obj.track0
local noiseAmplitude = obj.track1
local noiseFrequency = obj.track2 * 0.001
local noiseEvolution = obj.track3

local fieldSizeX = obj.screen_w / 2 - 200
local fieldSizeY = fieldSizeX


--== Import rikky_module ==--
package.cpath = package.cpath .. ";" .. obj.getinfo ("script_path"):match ("(.*\\).*\\") .. "?.dll"
local bool, rikky_module = pcall (require, "rikky_module")

if not bool then
	obj.load ("<s100>require rikky_module!")
	obj.draw()

	return
end
--=========================--


--== Functions ==--
local function lerp (t, a, b)
	return a + t * (b - a)
end


--== 3D Perlin Noise Class ==--
local PerlinNoise3D = {}

function PerlinNoise3D.new()
	local obj = {
		permutation = {
			151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,
			69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,
			94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,
			171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,
			60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,
			1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,
			164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,
			255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,
			119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,
			19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,
			238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,
			181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,
			222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
		},
		dot_product = {
			[0x0] = function (x, y, z) return  x + y end,
			[0x1] = function (x, y, z) return -x + y end,
			[0x2] = function (x, y, z) return  x - y end,
			[0x3] = function (x, y, z) return -x - y end,
			[0x4] = function (x, y, z) return  x + z end,
			[0x5] = function (x, y, z) return -x + z end,
			[0x6] = function (x, y, z) return  x - z end,
			[0x7] = function (x, y, z) return -x - z end,
			[0x8] = function (x, y, z) return  y + z end,
			[0x9] = function (x, y, z) return -y + z end,
			[0xA] = function (x, y, z) return  y - z end,
			[0xB] = function (x, y, z) return -y - z end,
			[0xC] = function (x, y, z) return  y + x end,
			[0xD] = function (x, y, z) return -y + z end,
			[0xE] = function (x, y, z) return  y - x end,
			[0xF] = function (x, y, z) return -y - z end,
		},
		p = {},
	}

	for i = 0, 255 do
		obj.p[i] =       obj.permutation[i + 1]
		obj.p[i + 256] = obj.permutation[i + 1]
	end

	return setmetatable (obj, { __index = PerlinNoise3D })
end

function PerlinNoise3D.fade (t)
	return t * t * t * (t * (t * 6 - 15) + 10)
end

function PerlinNoise3D.lerp (t, a, b)
	return a + t * (b - a)
end

function PerlinNoise3D.grad (self, hash, x, y, z)
	return self.dot_product[bit.band(hash, 0xF)](x, y, z)
end

function PerlinNoise3D.noise (self, x, y, z)
	y = y or 0
	z = z or 0

	-- Calculate the "unit cube" that the point asked will be located in
    local xi = bit.band (math.floor(x), 255)
    local yi = bit.band (math.floor(y), 255)
    local zi = bit.band (math.floor(z), 255)

	-- Next we calculate the location (from 0 to 1) in that cube
    x = x - math.floor (x)
    y = y - math.floor (y)
    z = z - math.floor (z)

	-- We also fade the location to smooth the result
    local u = self.fade (x)
    local v = self.fade (y)
    local w = self.fade (z)

	-- Hash all 8 unit cube coordinates surrounding input coordinate
    local p = self.p
    local A, AA, AB, AAA, ABA, AAB, ABB, B, BA, BB, BAA, BBA, BAB, BBB
    A   = p[xi  ] + yi
    AA  = p[A   ] + zi
    AB  = p[A+1 ] + zi
    AAA = p[ AA ]
    ABA = p[ AB ]
    AAB = p[ AA+1 ]
    ABB = p[ AB+1 ]

    B   = p[xi+1] + yi
    BA  = p[B   ] + zi
    BB  = p[B+1 ] + zi
    BAA = p[ BA ]
    BBA = p[ BB ]
    BAB = p[ BA+1 ]
    BBB = p[ BB+1 ]

	-- Take the weighted average between all 8 unit cube coordinates
    return self.lerp (w,
        self.lerp (v,
            self.lerp (u,
                self.grad (self, AAA, x, y, z),
                self.grad (self, BAA, x - 1, y, z)
            ),
            self.lerp (u,
                self.grad (self, ABA, x, y - 1, z),
                self.grad (self, BBA, x - 1, y - 1, z)
            )
        ),
        self.lerp (v,
            self.lerp (u,
                self.grad (self, AAB, x, y, z - 1),
				self.grad (self, BAB, x - 1, y, z - 1)
            ),
            self.lerp (u,
                self.grad (self, ABB, x, y - 1, z - 1),
				self.grad (self, BBB, x - 1, y - 1, z - 1)
            )
		)
    )
end


--== Main Processing ==--
--** Draw **--
local fieldGapX = fieldSizeX / (resolution - 1)
local fieldGapY = fieldSizeY / (resolution - 1)

local fieldCenterX = fieldSizeX / 2
local fieldCenterY = fieldSizeY / 2

local noiseDimensionOffset = 100
local perlin = PerlinNoise3D.new()

local currentFrame, totalFrame = rikky_module.getinfo ("frame")
local audioOffset = 0
local startFrequency = 20
local endFrequency = 400

local audioStrength = 0

local width = 9
for i = 1, width do
	local spectrumBuffer = rikky_module.audiobuffer (currentFrame + audioOffset + i, "FOURIER", "absolute", "monaural", 1024, 3, { startFrequency, endFrequency })
	for j = 1, #spectrumBuffer do
		audioStrength = audioStrength + spectrumBuffer[j] / #spectrumBuffer / width
	end
end

noiseAmplitude = (audioStrength * 0.01) * noiseAmplitude

obj.load ("figure", "円", color, pointerSize)

for xi = 0, resolution - 1 do
	for yi = 0, resolution - 1 do
		--** Generate Field **--
		local x, y, z = 0, 0, 0

		x = xi * fieldGapX - fieldCenterX
		y = yi * fieldGapY - fieldCenterY

		x = x + noiseAmplitude * perlin.noise (perlin, noiseFrequency * xi + noiseDimensionOffset, noiseFrequency * yi,                        noiseFrequency * noiseEvolution)
		y = y + noiseAmplitude * perlin.noise (perlin, noiseFrequency * xi,                        noiseFrequency * yi + noiseDimensionOffset, noiseFrequency * noiseEvolution)
		z = z + noiseAmplitude * perlin.noise (perlin, noiseFrequency * xi,                        noiseFrequency * yi,                        noiseFrequency * noiseEvolution + noiseDimensionOffset)


		--** Spherical Coordinates **--
		-- local radius = obj.screen_w / 4
		-- local strength = 1

		-- local distance = math.sqrt (x * x + y * y)
		-- local unitX = x / distance
		-- local unitY = y / distance

		-- if (distance <= radius) then
		-- 	x = lerp (strength, x, unitX * radius)
		-- 	y = lerp (strength, y, unitY * radius)
		-- end


		obj.draw (x, y, z)
	end
end

--** Debugging **--
if (DEBUG_MODE) then
	obj.load ("text", audioStrength, 0xffffff, 0)
	obj.draw()
end


--== Post Processing ==--
obj.load ("tempbuffer")
obj.effect()
